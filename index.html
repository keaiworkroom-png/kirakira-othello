<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

<title>ã‚­ãƒ©ã‚­ãƒ©ã‚ªã‚»ãƒ­</title>

<!-- PWAé¢¨ï¼ˆãƒ›ãƒ¼ãƒ ç”»é¢è¿½åŠ ã§â€œã‚¢ãƒ—ãƒªã£ã½ãâ€ï¼‰ -->
<meta name="theme-color" content="#ff4fb3" />

<!-- iPhone ãƒ›ãƒ¼ãƒ ç”»é¢ã‚¢ã‚¤ã‚³ãƒ³ -->
<link rel="apple-touch-icon" href="icons/apple-touch-icon.png" />

<!-- iPhoneï¼šãƒ›ãƒ¼ãƒ ç”»é¢èµ·å‹•ã‚’â€œå…¨ç”»é¢â€ã«ã™ã‚‹ -->
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="ã‚­ãƒ©ã‚­ãƒ©ã‚ªã‚»ãƒ­" />

<!-- iOSã®ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢ï¼ˆãƒãƒƒãƒï¼‰ã«å¯¾å¿œ -->
<style>
  body{
    margin: 0;
    padding:
      env(safe-area-inset-top)
      env(safe-area-inset-right)
      env(safe-area-inset-bottom)
      env(safe-area-inset-left);
  }
</style>
</head>

<body>
<div class="fx" aria-hidden="true"></div>

<div class="wrap safeBottom">
  <header>
    <div class="brand">
      <div class="title">ã‚­ãƒ©ã‚­ãƒ© ã‚ªã‚»ãƒ­ <span class="pill"><span class="heart" aria-hidden="true"></span> ãƒ”ãƒ³ã‚¯Ã—ãƒ›ãƒ¯ã‚¤ãƒˆ</span></div>
      <div class="pill" id="modePill">ãƒ¢ãƒ¼ãƒ‰ï¼šâ€”</div>
    </div>

    <div class="topActions">
      <button class="btn small primary" id="newGameBtn">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
      <button class="btn small" id="rouletteBtn">å…ˆæ”»ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆ</button>
      <button class="btn small danger" id="resetStatsBtn">è¨˜éŒ²ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </header>

  <div class="grid">
    <div class="card boardCard">
      <div class="boardHeader">
        <div class="status">
          <div class="statusLine" id="turnLine">â€”</div>
          <div class="subLine" id="subLine">â€”</div>
        </div>
        <div class="scoreRow">
          <div class="badge"><span class="dot pink"></span>ãƒ”ãƒ³ã‚¯ <span id="pinkCount">2</span></div>
          <div class="badge"><span class="dot white"></span>ãƒ›ãƒ¯ã‚¤ãƒˆ <span id="whiteCount">2</span></div>
        </div>
      </div>

      <div class="boardWrap">
        <div class="board" id="board" role="grid" aria-label="ã‚ªã‚»ãƒ­ç›¤"></div>

        <div class="overlay" id="passOverlay" role="dialog" aria-modal="true">
          <div class="modal">
            <h2>ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ã‚ˆ</h2>
            <p style="margin:0 0 10px;color:var(--muted);font-weight:800;font-size:12px;line-height:1.6;">
              ãƒ‘ã‚¹ã—ã¦ç›¸æ‰‹ã®ç•ªã«ã™ã‚‹ã­ã€‚
            </p>
            <button class="passBtn" id="passBtn">ãƒ‘ã‚¹</button>
          </div>
        </div>

        <div class="overlay" id="rouletteOverlay" role="dialog" aria-modal="true">
          <div class="modal">
            <h2>å…ˆæ”»ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆ</h2>

            <div class="roulette">
              <div class="wheelWrap" aria-hidden="true">
                <div class="pointer"></div>
                <div class="glowRing"></div>
                <div class="wheel" id="wheel"></div>
                <div class="burst" id="burst"></div>
              </div>
            </div>

            <div class="spinText" id="rouletteText">ãã‚‹ãã‚‹â€¦ï¼</div>
            <div style="text-align:center;">
              <span class="resultPill" id="rouletteResult" style="display:none;"></span>
            </div>
            <div class="row" style="justify-content:center;margin-top:12px;">
              <button class="btn pink" id="spinBtn">å›ã™ï¼</button>
              <button class="btn" id="closeRouletteBtn">é–‰ã˜ã‚‹</button>
            </div>
          </div>
        </div>

        <div class="overlay" id="endOverlay" role="dialog" aria-modal="true">
          <div class="modal">
            <h2 id="endTitle">ã‚²ãƒ¼ãƒ çµ‚äº†</h2>
            <p id="endBody" style="margin:0 0 10px;color:var(--muted);font-weight:800;font-size:12px;line-height:1.6;"></p>
            <div class="row" style="justify-content:center;">
              <button class="btn primary" id="playAgainBtn">ã‚‚ã†ä¸€å›</button>
              <button class="btn" id="closeEndBtn">é–‰ã˜ã‚‹</button>
            </div>
          </div>
        </div>

      </div>
    </div>

    <aside class="card side">
      <div class="sectionTitle">ã‚²ãƒ¼ãƒ è¨­å®š</div>
      <div class="row">
        <select class="select" id="modeSelect" aria-label="å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰">
          <option value="cpu">CPUå¯¾æˆ¦</option>
          <option value="pvp">2äººå¯¾æˆ¦</option>
        </select>

        <select class="select" id="levelSelect" aria-label="CPUé›£æ˜“åº¦">
          <option value="1">CPU Lv1ï¼ˆã‚†ã‚‹ã‚†ã‚‹ï¼‰</option>
          <option value="2">CPU Lv2ï¼ˆã‚„ã•ã—ã„ï¼‰</option>
          <option value="3" selected>CPU Lv3ï¼ˆå°1ãŒå‹ã¦ã‚‹ç›®å®‰ï¼‰</option>
          <option value="4">CPU Lv4ï¼ˆã¤ã‚ˆã‚ï¼‰</option>
          <option value="5">CPU Lv5ï¼ˆæœ¬æ°—ï¼‰</option>
        </select>
      </div>

      <div class="sectionTitle">ç´¯è¨ˆè¨˜éŒ²</div>
      <div class="kpi">
        <div class="box">
          <div class="num" id="gamesTotal">0</div>
          <div class="lab">ã‚²ãƒ¼ãƒ æ•°</div>
        </div>
        <div class="box">
          <div class="num"><span id="pinkWins">0</span> - <span id="whiteWins">0</span></div>
          <div class="lab">å‹ã¡ï¼ˆãƒ”ãƒ³ã‚¯-ãƒ›ãƒ¯ã‚¤ãƒˆï¼‰</div>
        </div>
        <div class="box">
          <div class="num" id="draws">0</div>
          <div class="lab">å¼•ãåˆ†ã‘</div>
        </div>
        <div class="box">
          <div class="num" id="winRate">â€”</div>
          <div class="lab">ãƒ”ãƒ³ã‚¯å‹ç‡</div>
        </div>
      </div>

      <div class="sectionTitle">ãƒ’ãƒ³ãƒˆ</div>
      <div class="note">
        ãƒ»ç½®ã‘ã‚‹å ´æ‰€ï¼ˆã†ã™ã„ä¸¸ï¼‰ãŒå‡ºã‚‹ã‚ˆã€‚<br>
        ãƒ»ãƒ‘ã‚¹ãŒå¿…è¦ãªã¨ãã¯ã€ç›¤ã®çœŸã‚“ä¸­ã«ãƒœã‚¿ãƒ³ãŒå‡ºã‚‹ã‚ˆã€‚<br>
        ãƒ»CPUå¯¾æˆ¦ã§ã¯ã€ã‚ãªãŸã¯<strong>ãƒ”ãƒ³ã‚¯å›ºå®š</strong>ã ã‚ˆã€‚<br>
        ãƒ»å¯¾æˆ¦é–‹å§‹æ™‚ã¯<strong>è‡ªå‹•ã§ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆ</strong>ãŒå›ã‚‹ã‚ˆï¼ˆCPUæˆ¦ã‚‚ï¼ï¼‰
      </div>

      <div class="sectionTitle">æ“ä½œ</div>
      <div class="row">
        <button class="btn primary" id="hintToggleBtn">ãƒ’ãƒ³ãƒˆï¼šON</button>
        <button class="btn" id="undoBtn" title="1æ‰‹ã ã‘æˆ»ã™ï¼ˆCPUæˆ¦ã¯ã‚ãªãŸã®æ‰‹ã¾ã§ï¼‰">1æ‰‹ã‚‚ã©ã™</button>
      </div>
    </aside>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const SIZE = 8;
  const EMPTY = 0;
  const PINK = 1;
  const WHITE = -1;
  const DIRS = [
    [-1,-1],[-1,0],[-1,1],
    [0,-1],        [0,1],
    [1,-1],[1,0],[1,1]
  ];

  const boardEl = document.getElementById('board');
  const turnLine = document.getElementById('turnLine');
  const subLine  = document.getElementById('subLine');
  const pinkCountEl = document.getElementById('pinkCount');
  const whiteCountEl = document.getElementById('whiteCount');

  const modeSelect = document.getElementById('modeSelect');
  const levelSelect = document.getElementById('levelSelect');
  const modePill = document.getElementById('modePill');

  const newGameBtn = document.getElementById('newGameBtn');
  const rouletteBtn = document.getElementById('rouletteBtn');
  const resetStatsBtn = document.getElementById('resetStatsBtn');

  const passOverlay = document.getElementById('passOverlay');
  const passBtn = document.getElementById('passBtn');

  const rouletteOverlay = document.getElementById('rouletteOverlay');
  const wheelEl = document.getElementById('wheel');
  const rouletteText = document.getElementById('rouletteText');
  const rouletteResult = document.getElementById('rouletteResult');
  const spinBtn = document.getElementById('spinBtn');
  const closeRouletteBtn = document.getElementById('closeRouletteBtn');
  const burstEl = document.getElementById('burst');

  const endOverlay = document.getElementById('endOverlay');
  const endTitle = document.getElementById('endTitle');
  const endBody = document.getElementById('endBody');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const closeEndBtn = document.getElementById('closeEndBtn');

  const gamesTotalEl = document.getElementById('gamesTotal');
  const pinkWinsEl = document.getElementById('pinkWins');
  const whiteWinsEl = document.getElementById('whiteWins');
  const drawsEl = document.getElementById('draws');
  const winRateEl = document.getElementById('winRate');

  const hintToggleBtn = document.getElementById('hintToggleBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toastEl = document.getElementById('toast');

  let board = makeInitialBoard();
  let current = PINK;
  let gameMode = 'cpu';
  let cpuLevel = 3;

  let playerColor = PINK;
  let cpuColor = WHITE;

  let showHints = true;
  let isBusy = false;
  let history = [];
  let spinning = false;
  let rouletteAutoTimer = null;

  const CPU_DELAY_MS = 620;

  // â˜… ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆçµæœè¡¨ç¤ºã‚’+1ç§’ï¼ˆè‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚ºå»¶é•·ï¼‰
  const ROULETTE_AUTO_CLOSE_MS = 1900; // 900 -> 1900ï¼ˆ+1ç§’ï¼‰

  const STATS_KEY = 'sparkly_othello_stats_v1';
  let stats = loadStats();

  function makeEmptyBoard(){
    return Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
  }
  function makeInitialBoard(){
    const b = makeEmptyBoard();
    const m = SIZE/2;
    b[m-1][m-1] = WHITE;
    b[m][m]     = WHITE;
    b[m-1][m]   = PINK;
    b[m][m-1]   = PINK;
    return b;
  }
  function cloneBoard(b){ return b.map(row => row.slice()); }
  function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

  function getFlips(b, r, c, color){
    if (b[r][c] !== EMPTY) return [];
    const flips = [];
    for (const [dr,dc] of DIRS){
      let rr=r+dr, cc=c+dc;
      const line = [];
      while(inBounds(rr,cc) && b[rr][cc] === -color){
        line.push([rr,cc]);
        rr+=dr; cc+=dc;
      }
      if (line.length>0 && inBounds(rr,cc) && b[rr][cc] === color){
        flips.push(...line);
      }
    }
    return flips;
  }
  function getLegalMoves(b, color){
    const moves = [];
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const flips = getFlips(b,r,c,color);
        if (flips.length) moves.push({r,c,flips});
      }
    }
    return moves;
  }
  function applyMove(b, move, color){
    const nb = cloneBoard(b);
    nb[move.r][move.c] = color;
    for (const [rr,cc] of move.flips) nb[rr][cc] = color;
    return nb;
  }
  function countStones(b){
    let p=0,w=0;
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        if (b[r][c]===PINK) p++;
        else if (b[r][c]===WHITE) w++;
      }
    }
    return {p,w};
  }
  function isGameOver(b){
    return getLegalMoves(b, PINK).length === 0 && getLegalMoves(b, WHITE).length === 0;
  }

  function render(){
    const {p,w} = countStones(board);
    pinkCountEl.textContent = p;
    whiteCountEl.textContent = w;

    const turnName = current===PINK ? 'ãƒ”ãƒ³ã‚¯' : 'ãƒ›ãƒ¯ã‚¤ãƒˆ';
    const turnDot = current===PINK ? '<span class="dot pink"></span>' : '<span class="dot white"></span>';
    const modeText = (gameMode==='cpu') ? `CPUå¯¾æˆ¦ï¼ˆLv${cpuLevel}ï¼‰` : '2äººå¯¾æˆ¦';
    modePill.textContent = `ãƒ¢ãƒ¼ãƒ‰ï¼š${modeText}`;

    if (gameMode==='cpu'){
      const who = (current===playerColor) ? 'ã‚ãªãŸã®ç•ª' : 'CPUã®ç•ª';
      turnLine.innerHTML = `${turnDot} <span>${who}ï¼š${turnName}</span>`;
      subLine.textContent = `ã‚ãªãŸï¼ãƒ”ãƒ³ã‚¯å›ºå®š / å…ˆæ”»ã¯ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆã§æ±ºã¾ã‚‹ã‚ˆ`;
    }else{
      const who = (current===PINK) ? 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆãƒ”ãƒ³ã‚¯ï¼‰ã®ç•ª' : 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆãƒ›ãƒ¯ã‚¤ãƒˆï¼‰ã®ç•ª';
      turnLine.innerHTML = `${turnDot} <span>${who}</span>`;
      subLine.textContent = `å…ˆæ”»ã¯ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆã§æ±ºã¾ã‚‹ã‚ˆï¼ˆãƒ”ãƒ³ã‚¯ or ãƒ›ãƒ¯ã‚¤ãƒˆï¼‰`;
    }

    boardEl.innerHTML = '';
    const legal = showHints ? getLegalMoves(board, current) : [];
    const hintSet = new Set(legal.map(m => `${m.r},${m.c}`));

    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.setAttribute('role','gridcell');
        cell.dataset.r = r;
        cell.dataset.c = c;

        const v = board[r][c];
        if (v !== EMPTY){
          const stone = document.createElement('div');
          stone.className = 'stone ' + (v===PINK ? 'pink' : 'white');
          cell.appendChild(stone);
          cell.classList.add('disabled');
        }else{
          if (showHints && hintSet.has(`${r},${c}`) && !isBusy){
            const hint = document.createElement('div');
            hint.className = 'hint';
            cell.appendChild(hint);
          }
        }
        boardEl.appendChild(cell);
      }
    }

    maybeShowPass();
    renderStats();
  }

  function renderStats(){
    gamesTotalEl.textContent = stats.games;
    pinkWinsEl.textContent = stats.pinkWins;
    whiteWinsEl.textContent = stats.whiteWins;
    drawsEl.textContent = stats.draws;
    const total = stats.games;
    if (total>0){
      const rate = (stats.pinkWins / total) * 100;
      winRateEl.textContent = `${rate.toFixed(1)}%`;
    }else{
      winRateEl.textContent = 'â€”';
    }
  }

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=>toastEl.classList.remove('show'), 1600);
  }

  function pushHistory(){
    history.push({ board: cloneBoard(board), current });
    if (history.length > 140) history.shift();
  }
  function canUndo(){
    return history.length > 0 && !isBusy && !isGameOver(board);
  }
  function undo(){
    if (!canUndo()) return;
    if (gameMode==='cpu'){
      let snap = history.pop();
      board = snap.board; current = snap.current;
      if (current !== playerColor && history.length){
        snap = history.pop();
        board = snap.board; current = snap.current;
      }
    }else{
      const snap = history.pop();
      board = snap.board; current = snap.current;
    }
    toast('1æ‰‹ã‚‚ã©ã—ãŸã‚ˆ');
    render();
  }

  function endGame(){
    const {p,w} = countStones(board);
    let result;
    if (p>w) result = 'ãƒ”ãƒ³ã‚¯ã®å‹ã¡ï¼';
    else if (w>p) result = 'ãƒ›ãƒ¯ã‚¤ãƒˆã®å‹ã¡ï¼';
    else result = 'å¼•ãåˆ†ã‘ï¼';

    stats.games++;
    if (p>w) stats.pinkWins++;
    else if (w>p) stats.whiteWins++;
    else stats.draws++;
    saveStats(stats);

    endTitle.textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†';
    endBody.innerHTML = `çµæœï¼š<strong>${result}</strong><br>ãƒ”ãƒ³ã‚¯ ${p} / ãƒ›ãƒ¯ã‚¤ãƒˆ ${w}`;
    endOverlay.classList.add('show');
    renderStats();
  }

  function nextTurn(){
    if (isGameOver(board)){
      endGame();
      return;
    }
    maybeShowPass();
    render();

    if (gameMode==='cpu' && current === cpuColor){
      cpuThinkAndMove();
    }
  }

  function maybeShowPass(){
    const legal = getLegalMoves(board, current);
    if (legal.length === 0 && !isGameOver(board)){
      if (gameMode==='cpu' && current===cpuColor){
        setTimeout(()=>{
          if (isGameOver(board)) return;
          current = -current;
          toast('CPUã¯ç½®ã‘ãªã„ã®ã§ãƒ‘ã‚¹');
          nextTurn();
        }, 220);
      }else{
        passOverlay.classList.add('show');
      }
      return true;
    }else{
      passOverlay.classList.remove('show');
      return false;
    }
  }

  function doPass(){
    passOverlay.classList.remove('show');
    current = -current;
    toast('ãƒ‘ã‚¹ã—ãŸã‚ˆ');
    nextTurn();
  }

  function handleCellClick(r,c){
    if (isBusy) return;
    if (endOverlay.classList.contains('show')) return;
    if (rouletteOverlay.classList.contains('show')) return;
    if (passOverlay.classList.contains('show')) return;

    if (gameMode==='cpu' && current !== playerColor) return;

    const legal = getLegalMoves(board, current);
    const move = legal.find(m => m.r===r && m.c===c);
    if (!move){
      toast('ãã“ã«ã¯ç½®ã‘ãªã„ã‚ˆ');
      return;
    }
    pushHistory();
    board = applyMove(board, move, current);
    current = -current;
    nextTurn();
  }

  function burst(){
    burstEl.innerHTML = '';
    const icons = ['ğŸ’–','âœ¨','ğŸ’—','ğŸŒŸ','ğŸ’•'];
    const n = 12;
    for (let i=0;i<n;i++){
      const s = document.createElement('span');
      s.textContent = icons[Math.floor(Math.random()*icons.length)];
      const ang = (Math.PI*2) * (i/n);
      const dx = Math.cos(ang) * (22 + Math.random()*34);
      const dy = Math.sin(ang) * (22 + Math.random()*34);
      s.style.setProperty('--dx', `${dx}px`);
      s.style.setProperty('--dy', `${dy}px`);
      s.style.animationDelay = `${Math.random()*120}ms`;
      burstEl.appendChild(s);
    }
  }

  function openRoulette({autoSpin=false}={}){
    rouletteResult.style.display = 'none';
    rouletteResult.textContent = '';
    rouletteText.textContent = autoSpin ? 'è‡ªå‹•ã§å›ã™ã‚ˆâ€¦ï¼' : 'ãã‚‹ãã‚‹â€¦ï¼';
    wheelEl.style.transition = 'none';
    wheelEl.style.transform = 'rotate(0deg)';
    rouletteOverlay.classList.add('show');
    spinning = false;

    clearTimeout(rouletteAutoTimer);
    if (autoSpin){
      rouletteAutoTimer = setTimeout(()=>spinRoulette(true), 500);
    }
  }

  function closeRoulette(){
    if (spinning) return;
    rouletteOverlay.classList.remove('show');
  }

  function spinRoulette(isAuto=false){
    if (spinning) return;
    spinning = true;
    rouletteResult.style.display = 'none';
    rouletteText.textContent = isAuto ? 'ãã‚‹ãã‚‹â€¦ï¼ˆè‡ªå‹•ï¼‰' : 'ã„ãã‚ˆâ€¦ï¼';
    spinBtn.disabled = true;
    closeRouletteBtn.disabled = true;

    const startColor = (Math.random() < 0.5) ? PINK : WHITE;

    const base = 360 * (5 + Math.floor(Math.random()*3));
    const offset = (startColor===PINK) ? 18 : 198;
    const deg = base + offset + Math.floor(Math.random()*26);
    wheelEl.style.transition = 'transform 1.55s cubic-bezier(.08,.82,.18,1)';
    wheelEl.style.transform = `rotate(${deg}deg)`;

    rouletteText.textContent = 'ã‚«ãƒã‚«ãƒã‚«ãƒâ€¦âœ¨';

    setTimeout(()=>{
      burst();
      const label = (startColor===PINK) ? 'ãƒ”ãƒ³ã‚¯ãŒå…ˆæ”»ï¼' : 'ãƒ›ãƒ¯ã‚¤ãƒˆãŒå…ˆæ”»ï¼';
      rouletteText.textContent = 'æ±ºã¾ã£ãŸï¼ğŸ’–';
      rouletteResult.innerHTML = `${startColor===PINK ? '<span class="dot pink"></span>' : '<span class="dot white"></span>'} ${label}`;
      rouletteResult.style.display = 'inline-flex';

      current = startColor;

      if (gameMode==='cpu'){
        playerColor = PINK;
        cpuColor = WHITE;
      }

      spinning = false;
      spinBtn.disabled = false;
      closeRouletteBtn.disabled = false;

      render();

      if (gameMode==='cpu' && current===cpuColor){
        setTimeout(()=>cpuThinkAndMove(), CPU_DELAY_MS);
      }

      // â˜… çµæœè¡¨ç¤ºã‚’é•·ãï¼ˆ+1ç§’ï¼‰
      if (isAuto){
        setTimeout(()=>closeRoulette(), ROULETTE_AUTO_CLOSE_MS);
      }
    }, 1600);
  }

  // CPUï¼ˆãã®ã¾ã¾ï¼‰
  const CORNERS = new Set(["0,0","0,7","7,0","7,7"]);
  function isEdge(r,c){ return r===0||r===7||c===0||c===7; }
  function isXSq(r,c){
    return (r===1&&c===1)||(r===1&&c===6)||(r===6&&c===1)||(r===6&&c===6);
  }
  function cornerEmptyNear(b,r,c){
    if (r===1&&c===1) return b[0][0]===EMPTY;
    if (r===1&&c===6) return b[0][7]===EMPTY;
    if (r===6&&c===1) return b[7][0]===EMPTY;
    if (r===6&&c===6) return b[7][7]===EMPTY;
    return false;
  }
  function evaluate(b, color){
    const opp = -color;
    const {p,w} = countStones(b);
    const my = (color===PINK)?p:w;
    const op = (color===PINK)?w:p;

    const m1 = getLegalMoves(b, color).length;
    const m2 = getLegalMoves(b, opp).length;

    let c1=0,c2=0;
    for (const key of CORNERS){
      const [r,c] = key.split(',').map(Number);
      if (b[r][c]===color) c1++;
      else if (b[r][c]===opp) c2++;
    }

    let e1=0,e2=0;
    for (let i=0;i<SIZE;i++){
      const pts = [[0,i],[7,i],[i,0],[i,7]];
      for (const [r,c] of pts){
        if (b[r][c]===color) e1++;
        else if (b[r][c]===opp) e2++;
      }
    }

    const piece = (my - op);
    const mobility = (m1 - m2) * 6;
    const corners = (c1 - c2) * 60;
    const edges = (e1 - e2) * 3;

    const filled = my + op;
    const late = filled > 52;
    const pieceWeight = late ? 3 : 1;

    return corners + mobility + edges + piece*pieceWeight;
  }

  function pickByHeuristic(legal, b, color, randomness){
    const scored = legal.map(m => {
      const nb = applyMove(b, m, color);
      let s = evaluate(nb, color);
      const key = `${m.r},${m.c}`;
      if (CORNERS.has(key)) s += 120;
      if (isXSq(m.r,m.c) && cornerEmptyNear(b,m.r,m.c)) s -= 70;
      if (isEdge(m.r,m.c)) s += 8;
      return {m, s};
    }).sort((a,b)=>b.s-a.s);

    const best = scored[0].s;
    const threshold = best - Math.max(10, best*Math.min(.12, randomness));
    const pool = scored.filter(x => x.s >= threshold);
    return pool[Math.floor(Math.random()*pool.length)].m;
  }

  function pickSlightlyWorse(legal, b, color){
    const scored = legal.map(m => {
      const nb = applyMove(b, m, color);
      return {m, s: evaluate(nb, color)};
    }).sort((a,b)=>b.s-a.s);
    if (scored.length<=2) return scored[0].m;
    const start = Math.min(2, scored.length-1);
    const end = Math.min(scored.length-1, start + Math.max(2, Math.floor(scored.length*0.4)));
    const idx = start + Math.floor(Math.random()*(end-start+1));
    return scored[idx].m;
  }

  function minimaxPick(b, color, depth, noise){
    const legal = getLegalMoves(b, color);
    let best = null;
    let bestScore = -Infinity;
    for (const m of legal){
      const nb = applyMove(b, m, color);
      const score = minimax(nb, -color, depth-1, -Infinity, Infinity, color);
      const jitter = (Math.random()*2 - 1) * (noise * 20);
      const s = score + jitter;
      if (s > bestScore){
        bestScore = s;
        best = m;
      }
    }
    return best || legal[0];
  }

  function minimax(b, turn, depth, alpha, beta, rootColor){
    if (depth<=0 || isGameOver(b)){
      return evaluate(b, rootColor);
    }
    const moves = getLegalMoves(b, turn);
    if (moves.length===0){
      return minimax(b, -turn, depth-1, alpha, beta, rootColor);
    }
    const maximizing = (turn === rootColor);
    if (maximizing){
      let value = -Infinity;
      for (const m of moves){
        const nb = applyMove(b, m, turn);
        value = Math.max(value, minimax(nb, -turn, depth-1, alpha, beta, rootColor));
        alpha = Math.max(alpha, value);
        if (alpha >= beta) break;
      }
      return value;
    }else{
      let value = Infinity;
      for (const m of moves){
        const nb = applyMove(b, m, turn);
        value = Math.min(value, minimax(nb, -turn, depth-1, alpha, beta, rootColor));
        beta = Math.min(beta, value);
        if (alpha >= beta) break;
      }
      return value;
    }
  }

  function cpuThinkAndMove(){
    if (isBusy) return;
    isBusy = true;
    render();

    const legal = getLegalMoves(board, cpuColor);
    if (legal.length===0){
      isBusy = false;
      current = -current;
      toast('CPUã¯ç½®ã‘ãªã„ã®ã§ãƒ‘ã‚¹');
      nextTurn();
      return;
    }

    const level = cpuLevel|0;
    let move;

    if (level===1){
      move = legal[Math.floor(Math.random()*legal.length)];
    }else if (level===2){
      move = pickByHeuristic(legal, board, cpuColor, 0.35);
    }else if (level===3){
      if (Math.random() < 0.30){
        move = legal[Math.floor(Math.random()*legal.length)];
      }else{
        move = pickByHeuristic(legal, board, cpuColor, 0.55);
      }
      if (Math.random() < 0.18){
        move = pickSlightlyWorse(legal, board, cpuColor);
      }
    }else if (level===4){
      move = minimaxPick(board, cpuColor, 2, 0.12);
    }else{
      move = minimaxPick(board, cpuColor, 3, 0.06);
    }

    setTimeout(()=>{
      pushHistory();
      board = applyMove(board, move, cpuColor);
      current = -cpuColor;
      isBusy = false;
      nextTurn();
    }, CPU_DELAY_MS);
  }

  function loadStats(){
    try{
      const raw = localStorage.getItem(STATS_KEY);
      if (!raw) return {games:0,pinkWins:0,whiteWins:0,draws:0};
      const s = JSON.parse(raw);
      return {
        games: +s.games||0,
        pinkWins: +s.pinkWins||0,
        whiteWins: +s.whiteWins||0,
        draws: +s.draws||0
      };
    }catch{
      return {games:0,pinkWins:0,whiteWins:0,draws:0};
    }
  }
  function saveStats(s){ localStorage.setItem(STATS_KEY, JSON.stringify(s)); }
  function resetStats(){
    stats = {games:0,pinkWins:0,whiteWins:0,draws:0};
    saveStats(stats);
    toast('è¨˜éŒ²ã‚’ãƒªã‚»ãƒƒãƒˆã—ãŸã‚ˆ');
    renderStats();
  }

  function newGame(keepMode=true){
    board = makeInitialBoard();
    history = [];
    isBusy = false;

    if (!keepMode){
      gameMode = modeSelect.value;
      cpuLevel = parseInt(levelSelect.value,10);
    }

    if (gameMode==='cpu'){
      playerColor = PINK;
      cpuColor = WHITE;
    }

    current = PINK;
    passOverlay.classList.remove('show');
    endOverlay.classList.remove('show');

    render();

    setTimeout(()=>{ openRoulette({autoSpin:true}); }, 450);
  }

  // Events
  boardEl.addEventListener('click', (e)=>{
    const cell = e.target.closest('.cell');
    if (!cell) return;
    handleCellClick(+cell.dataset.r, +cell.dataset.c);
  });

  passBtn.addEventListener('click', doPass);
  newGameBtn.addEventListener('click', ()=> newGame(false));
  rouletteBtn.addEventListener('click', ()=> openRoulette({autoSpin:false}));

  modeSelect.addEventListener('change', ()=>{
    gameMode = modeSelect.value;
    levelSelect.disabled = (gameMode!=='cpu');
    newGame(true);
    toast(gameMode==='cpu' ? 'CPUå¯¾æˆ¦ã«ã—ãŸã‚ˆï¼ˆã‚ãªãŸã¯ãƒ”ãƒ³ã‚¯ï¼‰' : '2äººå¯¾æˆ¦ã«ã—ãŸã‚ˆ');
  });

  levelSelect.addEventListener('change', ()=>{
    cpuLevel = parseInt(levelSelect.value,10);
    if (gameMode==='cpu'){
      newGame(true);
      toast(`CPUãƒ¬ãƒ™ãƒ«ã‚’Lv${cpuLevel}ã«ã—ãŸã‚ˆ`);
    }
  });

  resetStatsBtn.addEventListener('click', ()=>{
    if (confirm('ç´¯è¨ˆè¨˜éŒ²ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰')){
      resetStats();
    }
  });

  spinBtn.addEventListener('click', ()=>spinRoulette(false));
  closeRouletteBtn.addEventListener('click', closeRoulette);
  rouletteOverlay.addEventListener('click', (e)=>{
    if (e.target === rouletteOverlay) closeRoulette();
  });

  playAgainBtn.addEventListener('click', ()=>{
    endOverlay.classList.remove('show');
    newGame(true);
  });
  closeEndBtn.addEventListener('click', ()=> endOverlay.classList.remove('show'));
  endOverlay.addEventListener('click', (e)=>{
    if (e.target === endOverlay) endOverlay.classList.remove('show');
  });

  hintToggleBtn.addEventListener('click', ()=>{
    showHints = !showHints;
    hintToggleBtn.textContent = `ãƒ’ãƒ³ãƒˆï¼š${showHints ? 'ON' : 'OFF'}`;
    render();
  });

  undoBtn.addEventListener('click', undo);

  window.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape'){
      passOverlay.classList.remove('show');
      if (!spinning) rouletteOverlay.classList.remove('show');
      endOverlay.classList.remove('show');
    }
  });

  function init(){
    gameMode = modeSelect.value;
    cpuLevel = parseInt(levelSelect.value,10);
    levelSelect.disabled = (gameMode!=='cpu');

    renderStats();
    newGame(true);
  }

  init();
})();
</script>
</body>
</html>

